### lec12:分布式事务

分布式事务主要有两部分组成。第一个是**并发控制**（Concurrency Control）第二个是**原子提交**（Atomic Commit）。

之所以提及分布式事务，是因为对于拥有大量数据的人来说，他们通常会将数据进行分割或者分片到许多不同的服务器上。

假设你运行了一个银行，你一半用户的账户在一个服务器，另一半用户的账户在另一个服务器，这样的话可以同时满足**负载分担**和**存储空间**的要求。对于其他的场景也有类似的分片，比如说对网站上文章的投票，或许有上亿篇文章，那么可以在一个服务器上对一半的文章进行投票，在另一个服务器对另一半进行投票。

对于一些操作，可能会要求从多个服务器上修改或者读取数据。比如说我们从一个账户到另一个账户完成银行转账，这两个账户可能在不同的服务器上。因此，为了完成转账，我们必须要读取并修改两个服务器的数据。

一种构建系统的方式，就是向应用程序的开发人员，**隐藏将数据分割在多个服务器上带来的复杂度**。在过去的几十年间，这都是设计数据库需要考虑的问题，所以很多现在的材料的介绍都是基于数据库。这种方式（隐藏数据分片在多个服务器），现在在分布式系统也在广泛应用。

人们通常将**并发控制和原子提交**放在一起，当做事务。

可以这么理解事务：有一些不同的操作，或许针对数据库不同的记录，所有这些操作作为一个整体，不会因为失败而被分割，也不会被其他活动看到中间状态。

事务处理系统要求程序员对这些读操作、写操作标明起始和结束，这样才能知道事务的起始和结束。事务处理系统可以保证在事务的开始和结束之间的行为是可预期的。

例子：

```
这里有两个交易，第一个是从Y转账1块钱到X，另一个是对于所有的银行账户做审计，确保总的钱数不会改变。
为了用事务来描述这里的交易，我们需要有两个事务，第一个事务称为T1，程序员会标记它的开始，我们称之为BEGIN_X，之后是对于两个账户的操作，我们会对账户X加1，对账户Y加-1。之后我们需要标记事务的结束，我们称之为END_X。
T1:
	BEGIN_x
		add(x,1)
		add(y,-1)
	END_x
同时，我们还有一个事务，会检查所有的账户，对所有账户进行审计，确保尽管可能存在转账，但是所有账户的金额加起来总数是不变的。第二个事务是审计事务，我们称为T2。
这一次我们只是读数据，所以这是一个只读事务。我们需要获取所有账户的当前余额，因为现在我们只有两个账户，所以我们使用两个临时的变量，第一个是用来读取并存放账户X的余额，第二个用来读取并存放账户Y的余额，之后我们将它们都打印出来，最后是事务的结束。
T2:
	BEGIN_x
		t1=get(x)
		t2=get(y)
		print t1,t2
	END_x
```

**这两个事务的合法结果是什么？**

我们**需要一个概念**来定义**什么是正确的结果**。一旦我们知道了这个概念，我们需要构建能执行这些事务的机制，在可能存在并发和失败的前提下，仍然得到正确的结果。

什么是正确性？数据库通常对于正确性有一个概念称为ACID。

**Atomic，原子性。**事务可能有多个步骤，比如说写多个数据记录，尽管可能存在故障，但是要么所有的写数据都完成了，要么没有写数据能完成。不应该发生类似这种情况：在一个特定的时间发生了故障，导致事务中一半的写数据完成并可见，另一半的写数据没有完成，这里要么全有，要么全没有（All or Nothing）

**Consistent，一致性**。我们实际上不会担心这一条，它通常是指数据库会强制某些应用程序定义的数据不变。

**Isolated，隔离性**。这是一个属性，它表明两个同时运行的事务，在事务结束前，**不能看到彼此的更新**，**不能看到另一个事务中间的临时的更新**。隔离在技术上的具体体现是，**事务需要串行执行**。总结起来，事务**不能看到彼此之间的中间状态，只能看到完成的事务结果。**

**Durable，持久化的。**在事务提交之后，在客户端或者程序提交事务之后，并从数据库得到了回复，执行了事务，那么这时，**在数据库中的修改是持久化的**，它们不会因为一些错误而被擦除。在实际中，这意味着数据需要被写入到一些非易失的存储（Non-Volatile Storage），持久化的存储，例如磁盘。

通常来说，隔离性（Isolated）意味着**可序列化（**Serializable）

它的定义是如果在**同一时间并行**的执行一系列的**事务**，那么可以**生成一系列的结果。**这里的结果包括两个方面：1.由任何事务中的修改行为产生的数据库记录的**修改**；2.和任何事务生成的**输出**。所以前面例子中的两个事务，T1的结果是修改数据库记录，T2的结果是打印出数据。

**可序列化**是指，**并行的执行一些事物得到的结果**，与**按照某种串行的顺序**来执行这些事务，可以**得到相同的结果**。

```
我们先执行T1，再执行T2，我们得到X=11，Y=9，因为T1先执行，T2中的打印，可以看到这两个更新过后的数据，所以这里会打印字符串“11，9”。
另一种可能的顺序是，先执行T2，再执行T1，这种情况下，T2可以看到更新之前的数据，但是更新仍然会在T1中发生，所以最后的结果是X=11，Y=9。但是这一次，T2打印的是字符串“10，10”。
```

**如果你同时提交两个事务**，你不知道是T1，T2的顺序，还是T2，T1的顺序，所以你需要预期可能会有**超过一个合法的结果**。当你同时运行了更多的事务，结果也会更加复杂，可能会有**很多不同的正确的结果**，这些结果**都是可序列化**的，因为这里**对于事务存在许多顺序**，可以被用来满足序列化的要求。

**可序列化**是一个应用广泛且实用的定义，背后的原因是，它定义了事务执行过程的正确性。它是一个对于程序员来说是非常简单的编程模型，作为程序员你可以写非常复杂的事务而不用担心系统同时在运行什么，或许有许多其他的事务想要在相同的时间读写相同的数据，或许会发生错误，这些你都不需要关心。**可序列化特性**确保你可以安全的写你的事务，就像没有其他事情发生一样。因为系统最终的结果必须表现的就像，你的**事务在这种一次一个的顺序中是独占运行的**。这是一个非常简单，非常好的编程模型。

可序列化的另一方面优势是，只要事务不使用相同的数据，它可以允许真正的并行执行事务。我们之前的例子之所以有问题，是因为T1和T2都读取了数据X和Y。但是如果它们使用完全没有交集的数据库记录，那么这两个事务可以完全并行的执行。在一个分片的系统中，不同的数据在不同的机器上，你可以获得真正的并行速度提升，因为可能一个事务只会在第一个机器的第一个分片上执行，而另一个事务并行的在第二个机器上执行。所以，这里有可能可以获得更高的并发性能。

在事务执行的过程中，如果事务突然决定不能继续执行，这时事务可能已经修改了部分数据库记录，我们需要能够回退这些事务，并撤回任何已经做了的修改。

第一个有关实现的话题是并发控制（Concurrency Control）。这是我们用来**提供可序列化的主要工具**。所以**并发控制就是可序列化的别名**。通过与其他尝试**使用相同数据的并发事务进行隔离**，可以**实现可序列化**。

### 并发控制（Concurrency Control）

在并发控制中，主要有两种策略

- 第一种主要策略是**悲观并发控制**（Pessimistic Concurrency Control）

这里通常涉及到锁。实际上，数据库的**事务处理系统也会使用锁。**

在事务使用任何数据之前，它需要获得数据的锁。

如果一些其他的事务已经在使用这里的数据，锁会被它们持有，当前事务必须等待这些事务结束，之后当前事务才能获取到锁。

在悲观系统中，如果有锁冲突，比如**其他事务持有了锁，就会造成延时等待**。所以这里需要**为正确性而牺牲性能**。

- 第二种主要策略是乐观并发控制（Optimistic Concurrency Control）。

基本思想是，**不用担心其他的事务是否正在读写你要使用的数据**，你直接继续执行你的读写操作，通常来说这些执行会在一些临时区域，只有**在事务最后，检查是不是有一些其他的事务干扰了你**。如果没有这样的其他事务，那么你的事务就完成了，并且你也不需要承受锁带来的性能损耗，因为操作锁的代价一般都比较高；但是如果有一些**其他的事务在同一时间修改了你关心的数据**，并**造成了冲突**，那么你必须要**Abort当前事务**，并**重试**。这就是乐观并发控制。

实际，这两种策略哪个更好取决于不同的环境。如果冲突非常频繁，会想要使用悲观并发控制，因为如果冲突非常频繁的话，在乐观并发控制中你会有大量的Abort操作。如果冲突非常少，那么乐观并发控制可以更快，因为它完全避免了锁带来的性能损耗。

### **悲观并发控制**

这里涉及到的基本上就是锁机制。这里的锁是**两阶段锁**（Two-Phase Locking），这是一种最常见的锁。

对于两阶段锁来说，当事务需要使用一些数据记录时

1. 使用任何数据之前，**在执行任何数据的读写之前，先获取锁。**

2. 事务必须持有任何已经获得的锁，直到事务提交或者Abort，不允许在事务的中间过程释放锁。必须要持有所有的锁，并不断的累积持有的锁，直到你的事务完成了。所以，这里的规则是，**持有锁直到事务结束。**

所以，这就是两阶段锁的两个阶段，**第一个阶段获取锁**，**第二个阶段是在事务结束前一直持有锁。**

这里基本上**迫使事务串行执行**，在刚刚的例子中，两阶段锁迫使执行顺序是T2，T1。所以这里显式的迫使事务的执行遵循可序列化的定义，因为实际上就是T2完成之后，再执行T1。所以我们可以获得正确的执行结果。

**为什么需要在事务结束前一直持有锁？**

你或许会认为，你可以只在使用数据的时候持有锁，这样也会更有效率。在刚刚的例子中，或许只在T2获取记录X的数值时持有对X的锁，或许只在T1执行对X加1操作的时候持有对于X的锁，之后立即释放锁，虽然这样违反了两阶段锁的规则，但是如果立刻释放对于数据的锁，另一个事务可以早一点执行，我们就可以有更多的并发度，进而获得更高的性能。所以，**两阶段锁必然对于性能来说很糟糕**，所以我们才需要确认，它**对于正确性来说是必要的。**

如果在**修改完数据之后就释放锁**，还会有额外的问题。如果T1在执行完对X加1之后释放锁，它允许T2看到修改之后的X，之后T2会打印出这个结果。但是如果T1之后Abort了，或许因为银行账户Y并不存在，或许账户Y存在，但是余额为0，而我们不允许对于余额为0的账户再做减法，这样会造成透支。所以T1有可能会修改X，然后Abort。Abort的一部分工作就是要撤回对于X的修改，这样才能维持原子性。这意味着，如果T1释放了对于X的锁，事务T2会看到X的虚假数值11，这个数值最终不存在，因为T1中途Abort了，T2会看到一个永远不曾存在的数值。T2的结果最好是看起来就像是T2自己在运行，并没有T1的存在。但是这里，T2会看到X加1，然后打印出11，这与数据库的任何状态都对应不上。

所以，**使用了两阶段锁可以避免这两种违反可序列化特性的场景。**

对于这些规则，还有一些需要知道的事情。首先是，这里**非常容易产生死锁。**例如我们有两个事务，T1读取记录X，之后再读取记录Y，T2读取记录Y，之后再读取记录X。如果它们同时运行，这里就是个死锁。

每个事务都获取了第一个读取数据的锁，直到事务结束了，它们都不会释放这个锁。所以接下来，它们都会等待另一个事务持有的锁，除非数据库足够聪明，这里会永远死锁。实际上，事务有各种各样的策略，包括了判断循环，超时来判断它们是不是陷入到这样一个场景中。如果是的话，**数据库会Abort其中一个事务，撤回它所有的操作，并表现的像这个事务从来没有发生一样**

所以这就是使用**两阶段锁的并发控制**。这是一个完全标准的数据库行为，在一个单主机的数据库中是这样，在一个**分布式数据库也是这样**，不过会更加的有趣。

### 两阶段提交（Two-Phase Commit）

在一个分布式环境中，数据被分割在多台机器上，如何构建数据库或存储系统以支持事务。所以这个话题是，如何构建分布式事务（Distributed Transaction）

具体来说，**如何应付错误**，甚至是由多台机器中的一台引起的部分错误。这种**部分错误**在分布式系统中很常见。所以，在分布式事务之外，我们也要确保出现错误时，数据库仍然具有**可序列化**和某种程度的原子性。

问题

> 服务器2不能完成它在事务中应该做的那部分工作。但是服务器1又完成了它在事务中的那部分工作。这也是一种需要处理的问题。

我们想要的特性，就是要么系统中的每一部分都完成它们在事务中的工作，要么系统中的所有部分都不完成它们在事务中的工作。我们违反的规则是，在故障时**没有保证原子性**。

原子性是指，事务的每一个部分都执行，或者任何一个部分都不执行。很多时候，我们看到的解决方案是原子提交协议（Atomic Commit Protocols）。通常来说，原子提交协议的风格是：假设你有一批计算机，每一台都执行一个大任务的不同部分，原子提交协议将会帮助计算机来决定，它是否能够执行它对应的工作，它是否执行了对应的工作，又或者，某些事情出错了，所有计算机都要同意，没有一个会执行自己的任务。

**两阶段提交**不仅被分布式数据库所使用，同时也被各种看起来不像是传统数据库的分布式系统所使用。通常情况下，我们需要**执行的任务会以某种方式分包在多个服务器上**，**每个服务器需要完成任务的不同部分**。所以，在前一个例子中，实际上是**数据被分割在不同的服务器上**，所以相应的任务（为X加1，为Y减1）也被分包在不同的服务器上。我们将会假设，有一个计算机会用来**管理事务**，它被称为**事务协调者**（Transaction Coordinator）。事务协调者有很多种方法用来管理事务，我们这里就假设它是一个实际运行事务的计算机。在一个计算机上，事务协调者以某种形式运行事务的代码，例如Put/Get/Add，它向持有了不同数据的其他计算机发送消息，其他计算机再执行事务的不同部分。

EXAMPLE:

```
在我们的配置中，我们有一个计算机作为事务协调者（TC），然后还有服务器S1，S2，分别持有X，Y的记录
1.事务协调者会向服务器S1发消息说，请对X加1，向服务器S2发消息说，请对Y减1。
2.之后会有更多消息来确认，要么两个服务器都执行了操作，要么两个服务器都没有执行操作。这就是两阶段提交的实现框架。
```

在一个完整的系统中，或许会有很多不同的并发运行事务，也会有许多个**事务协调者在执行它们各自的事务**。在这个架构里的各个组成部分，都需要知道**消息对应的是哪个事务**。它们都会记录状态。每个持有数据的服务器会维护一个锁的表单，用来记录**锁被哪个事务所持有**。所以对于事务，需要有事务ID（Transaction ID），简称为TID。

```
假设系统中的每一个消息都被打上唯一的事务ID作为标记。这里的ID在事务开始的时候，由事务协调器来分配。这样事务协调器会发出消息说：这个消息是事务95的。同时事务协调器会在本地记录事务95的状态，对事务的参与者（例如服务器S1，S2）打上事务ID的标记。
```

我们有事务协调者，我们还有其他的服务器执行部分的事务，这些服务器被称为**参与者**（Participants）。

```
事务协调者运行了整个事务，它会向A，B发送Put和Get，告诉它们读取X，Y的数值，对X加1等等。所以，在事务的最开始，TC会向参与者A发送Get请求并得到回复，之后再向参与者B发送一个Put请求并得到回复。
这里只是举个例子，如果有一个复杂的事务，可能会有一个更长的请求序列。
```

当事务协调者到达了事务的结束并**想要提交事务**，这样才能：

- 释放所有的锁
- 使得事务的结果对于外部是可见的
- 向客户端回复

```
假设有一个外部的客户端C，它在最最开始的时候会向TC发请求说，请运行这个事务。并且之后这个客户端会等待回复。
```

1. 在开始执行事务时，TC需要确保，**所有的事务参与者能够完成它们在事务中的那部分工作**。更具体的，如果在事务中有任何Put请求，我们需要确保，执行Put的参与者仍然能执行Put。TC为了确保这一点，会向所有的参与者发送Prepare消息。

2. 当A或者B收到了Prepare消息，它们就知道事务要执行但是还没执行的内容，它们会**查看自身的状态并决定它们实际上能不能完成事务**。或许它们需要Abort这个事务因为这个事务会引起死锁，或许它们在故障重启过程中并完全忘记了这个事务因此不能完成事务。所以，A和B会检查自己的状态并说，我有能力或者我没能力完成这个事务，它们**会向TC回复Yes或者No。**

3. 事务协调者会等待来自于每一个参与者的这些Yes/No投票。如果**所有的参与者都回复Yes**，那么**事务可以提交**，不会发生错误。**之后事务协调者会发出一个Commit消息，给每一个事务的参与者**，

4. 事务参与者通常会回复ACK说，我们知道了要commit。

当事务协调者发出Prepare消息时，如果所有的参与者都回复Yes，那么事务可以commit。如果**任何一个参与者回复了No**，表明自己**不能完成这个事务**，或许是因为错误，或许有不一致性，或许丢失了记录，那么事务协调者**不会发送commit消息**

它会**发送一轮Abort消息**给所有的参与者说，请撤回这个事务。

在事务Commit之后，会发生两件事情。

1. 首先，事务协调者会**向客户端发送代表了事务输出的内容**，表明事务结束了，事务没有被Abort并且被**持久化保存**起来了。

2. 另一个有意思的事情是，为了遵守前面的锁规则（两阶段锁），事务**参与者会释放锁**（这里不论Commit还是Abort都会释放锁）。

实际上，为了遵循两阶段锁规则，每个事务**参与者**在参与事务时，会**对任何涉及到的数据加锁**。所以，在每个**参与者**中都会有个表单，**表单**会**记录数据当前是为哪个事务加的锁**。当**收到Commit或者Abort消息时**，事务参与者**会对数据解锁**，之后其他的事务才可以使用相应的数据。这里的解锁操作会解除对于其他事务的阻塞。这实际上是可序列化机制的一部分。

目前来说，还没有问题，因为架构中的每一个成员都遵循了协议，没有错误，两个参与者只会一起Commit，如果其中一个需要Abort，那么它们两个都会Abort。所以，基于刚刚描述的协议，如果没有错误的话，我们得到了这种**原子特性**。

### 故障恢复（Crash Recovery）

现在，我们需要在脑中设想各种可能发生的错误，并确认这里的**两阶段提交协议**是否仍然可以提供原子特性。如果不能的话，我们该如何调整或者扩展协议？

第一个我想考虑的错误是**故障重启**。我的意思是**类似于断电**，**服务器会突然中断执行**，当电力恢复之后，作为事务处理系统的一部分，服务器会运行一些**恢复软件**。这里实际上有两个场景需要考虑。

第一个场景是，参与者B可能在回复事务协调者的Prepare消息之前的崩溃了。

```
所以，B在回复Yes之前就崩溃了。从TC的角度来看，B没有回复Yes，TC也就不能Commit，因为它需要等待所有的参与者回复Yes。
如果B发现自己不可能发送Yes，比如说在发送Yes之前自己就故障了，那么B被授权可以单方面的Abort事务。因为B知道自己没有发送Yes，那么它也知道事务协调者不可能Commit事务。这里有很多种方法可以实现，其中一种方法是，因为B故障重启了，内存中的数据都会清除，所以B中所有有关事务的信息都不能活过故障，所以，故障之后B不知道任何有关事务的信息，也不知道给谁回复过Yes。之后，如果事务协调者发送了一个Prepare消息过来，因为B不知道事务，B会回复No，并要求Abort事务。
```

当然，B也可能在回复了Yes给事务协调者的Prepare消息之后崩溃的。

```
B可能回复给事务协调者说好的，我将会commit。但是在B收到来自事务协调者的commit消息之前崩溃了。
```

### 总结

**两阶段提交**，它实现了**原子提交**。两阶段提交在**大量的将数据分割在多个服务器上的分片数据库**或者存储系统中都有使用。两阶段提交可以支持读写多条记录，一些更特殊的存储系统不允许你在多条记录上支持事务。对于这些不支持事务中包含多条数据的系统，你就不需要两阶段提交。但是如果你需要在**事务中支持多条数据**，并且你将**数据分片在多台服务器**之上，那么你**必须支持两阶段提交**。

两阶段提交有着极差的名声。

- 其中一个原因是，因为有多轮消息的存在，它非常的慢。在上面的图中，各个组成部分之间着大量的交互。

- 另一个原因是，这里有大量的写磁盘操作，比如说B在回复Yes给Prepare消息之后不仅要向磁盘写入数据，还需要等待磁盘写入结束，如果你使用一个机械硬盘，这会花费10毫秒来完成Log数据的写入，这决定了事务的参与者能够以多快的速度处理事务。10毫秒完成Log写磁盘，那么最快就是每秒处理100个事务，这是一个非常慢的结果。同时，事务协调者也需要写磁盘，在收到所有Prepare消息的Yes回复之后，它也需要将Log写入磁盘，并等待磁盘写入结束。之后它才能发送Commit消息，这里又有了10毫秒。在这两个10毫秒内，锁都被参与者持有者，其他使用相关数据的事务都会被阻塞。

因此，你只会在一个小的环境中看到两阶段提交，比如说在一个组织的一个机房里面。你不会在不同的银行之间转账看到它，你或许可以在银行内部的系统中看见两阶段提交，但是你永远也不会在物理分隔的不同组织之间看见两阶段提交，因为它可能会陷入到Block区间中。你不会想将你的数据库的命运寄托在其他的数据库不在错误的时间崩溃，从而使得你的数据库被迫在很长一段时间持有锁

因为两阶段提交很慢，有很多很多的研究都是关于如何让它变得更快，比如以各种方式放松这里的规则进而使得它变得更快，又比如对于一些特定的场景做一些定制化从而避免一些消息

两阶段提交的架构中，本质上是有一个**Leader（事务协调者）**，将消息发送给**Follower（事务参与者）**，Leader只能在收到了足够多Follower的回复之后才能继续执行。这**与Raft非常像**，但是，这里**协议的属性与Raft又非常的不一样。**这两个协议解决的是完全不同的问题。

使用**Raft可**以通过将数据复制到多个参与者得到**高可用**。

Raft的意义在于，即使部分参与的服务器故障了或者不可达，系统仍然能工作。Raft能做到这一点是因为所有的服务器都在做相同的事情，所以我们不需要所有的服务器都参与，我们只需要过半服务器参与。然而两阶段提交，参与者完全没有在做相同的事情，每个参与者都在做事务中的不同部分，比如A可能在对X加1，B可能在对Y减1。所以在两阶段提交中，所有的参与者都在做不同的事情。所有的参与者都必须完成自己那部分工作，这样事务才能结束，所以这里需要等待所有的参与者。

**Raft通过复制可以不用每一个参与者都在线**，而**两阶段提交**每个参与者都做了不同的工作，并且每**个参与者的工作都必须完成**，所以**两阶段提交对于可用性没有任何帮助**。**Raft完全就是可用性**，而**两阶段提交完全不是高可用的**，系统中的任何一个部分出错了，系统都有可能等待直到这个部分修复。比如事务协调者在错误的时间崩溃了，我们需要等待它上线并读取它的Log再重发Commit消息。如果一个参与者在错误的时间崩溃了，如果我们足够幸运，我们只需要Abort事务。所以实际上，两阶段提交的可用性非常低，因为任何一个部分崩溃都有可能阻止整个系统的运行。Raft并不需要确保所有的参与者执行操作，它只需要过半服务器执行操作，或许少数的服务器完全没有执行操作也没关系。这里的原因是**Raft系统中**，所有的**参与者都在做相同的事情**，我们不必等待所有的参与者。这就是为什么Raft有更高的可用性。所以这是两个完全不同的协议。

然而，是有可能结合这两种协议的。两阶段提交对于故障来说是非常脆弱的，在故障时它可以有正确的结果，但是不具备可用性。所以，这里的问题是，是否可以构建一个合并的系统，同时具备Raft的高可用性，但同时又有两阶段提交的能力将事务分包给不同的参与者。这里的结构实际上是，**通过Raft或者Paxos**或者其他协议，来**复制两阶段提交协议里的每一个组成部分。**

所以，在前面的例子中，我们会有三个不同的集群，事务协调器会是一个复制的服务，包含了三个服务器，我们在这3个服务器上运行Raft，

其中一个服务器会被选为Leader，它们会有复制的状态，它们有Log来帮助它们复制，我们只需要等待过半服务器响应就可以执行事务协调器的指令。事务协调器还是会执行两阶段提交里面的各个步骤，并将这些步骤记录在自己的Raft集群的Log中。

每个事务参与者也同样是一个Raft集群。最终，消息会在这些集群之间传递。

这里很复杂，但是它展示了你可以**结合两种思想**来同时获得**高可用**和**原子提交**。

```
在Lab4，我们会构建一个类似的系统，实际上就是个分片的数据库，每个分片以这种形式进行复制，同时还有一个配置管理器，来允许将分片的数据从一个Raft集群移到另一个Raft集群。除此之外，我们还会读一篇论文叫做Spanner，它描述了Google使用的一种数据库，Spanner也使用了这里的结构来实现事务写。
```